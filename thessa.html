<!-- DISCLAIMER: A lot of this code was generated using AI -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="projects/images/thessa/favicon.ico" type="image/x-icon" />
    <meta name="description" content="An AI-powered thesaurus">
    <script src="common.js"></script>

    <title>Thessa</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&family=Sen:wght@400..800&display=swap');

        :root {
            --bg-color: #121212;
            --text-color: #f0f0f0;

            --teal-light: #a7f3e8;
            --teal-mid: #8fdfd4;
            --teal-dark: #6abfab;
            --teal-mid-rgb: 143, 223, 212;

            --accent-color: var(--teal-mid);
            --accent-gradient: linear-gradient(135deg, var(--teal-dark), var(--teal-mid), var(--teal-light));
            
            --accent-glow: rgba(143, 223, 212, 0.25); 
            --card-border-color: rgba(var(--teal-mid-rgb), 0.15); 
            --popover-bg: rgba(32, 32, 32, 0.97);
            --border-radius: 12px;
            --border-radius-large: 16px; 
            --modal-backdrop-color: rgba(0, 0, 0, 0.75);
            --success-color: #3fb950;
            --error-color: #f85149;

            --easing-standard: cubic-bezier(0.4, 0.0, 0.2, 1);
            --easing-emphasized: cubic-bezier(0.2, 0.0, 0, 1);
            --easing-decelerate: cubic-bezier(0.0, 0.0, 0.2, 1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            background-image:
                radial-gradient(circle at 5% 15%, rgba(var(--teal-mid-rgb), 0.08) 0%, transparent 35%),
                radial-gradient(circle at 95% 85%, rgba(var(--teal-mid-rgb), 0.06) 0%, transparent 30%),
                linear-gradient(180deg, rgba(18,18,18,0) 0%, rgba(18,18,18,0.05) 100%);
            background-attachment: fixed;
        }

        main {
            margin-top: 5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 5rem - 85px);
            overflow-x: hidden;
            width: 100%; 
            max-width: none; 
            padding: 0; 
            background: transparent; 
            border-radius: 0; 
            box-shadow: none; 
            text-align: center;
            animation: fadeInContainer 0.8s var(--easing-decelerate) forwards;
        }

        @keyframes fadeInContainer {
            from { opacity: 0; transform: translateY(25px) scale(0.99); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .header-title {
            display: flex;
            align-items: center;
            justify-content: center; 
            gap: 12px;
            margin-bottom: 10px;
        }

        h1 {
            font-family: 'Sen', sans-serif;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: inline-block;
            font-weight: 700;
            font-size: 3rem;
            letter-spacing: 0.2px;
            text-shadow: 0 0 20px var(--accent-glow);
        }

        .info-icon {
            cursor: pointer;
            color: var(--accent-color);
            opacity: 0.8;
            transition: opacity 0.2s var(--easing-standard), transform 0.2s var(--easing-standard), color 0.2s var(--easing-standard);
        }
        .info-icon:hover {
            opacity: 1;
            transform: scale(1.15) rotate(10deg);
            color: var(--teal-light);
        }
        /* Specific hover for settings icon if needed, otherwise shares .info-icon */
        #settings-btn:hover { 
            transform: scale(1.15) rotate(15deg); /* Slightly different rotation */
        }


        .tagline {
            font-family: 'Sen', sans-serif;
            font-size: 1rem;
            color: rgba(240, 240, 240, 0.75);
            margin-bottom: 45px;
            font-weight: 400;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeInTagline 0.7s var(--easing-decelerate) 0.2s forwards;
            max-width: 650px; 
            margin-left: auto;
            margin-right: auto; 
        }
        @keyframes fadeInTagline {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .input-area {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            width: 100%; 
            max-width: 850px; 
            margin-left: auto; 
            margin-right: auto; 
        }

        #word-input, #apiKeyInput /* Shared style for API key input */ {
            flex-grow: 1;
            padding: 18px 24px;
            height: 60px;
            border-radius: var(--border-radius);
            border: 1px solid var(--card-border-color);
            background-color: rgba(255,255,255, 0.03);
            color: var(--text-color);
            font-size: 1.1rem;
            transition: all 0.25s var(--easing-standard);
            outline: none;
        }

        #word-input:focus, #apiKeyInput:focus {
            border-color: var(--teal-mid);
            background-color: rgba(255,255,255, 0.05);
            box-shadow: 0 0 0 4px rgba(var(--teal-mid-rgb), 0.2), 0 2px 8px rgba(0,0,0,0.1) inset;
        }

        #word-input::placeholder, #apiKeyInput::placeholder {
            color: rgba(240, 240, 240, 0.5);
        }

        #generate-btn, #saveApiKeyBtn /* Shared style for main action buttons */ {
            width: 60px;
            height: 60px;
            padding: 0;
            background: var(--accent-gradient);
            color: var(--bg-color);
            border: none;
            border-radius: 50%; /* Default to circle for generate-btn */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s var(--easing-standard);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0,0,0, 0.15);
        }
        #saveApiKeyBtn { /* Specific overrides for Save API Key button */
            width: auto; /* Auto width based on content */
            padding: 12px 25px; /* More typical button padding */
            border-radius: var(--border-radius); /* Rectangular with rounded corners */
            height: auto; /* Auto height */
            margin: 20px auto 0 auto; /* Centering and top margin */
            display: block; /* For margin auto to work */
        }

        #generate-btn:hover:not(:disabled), #saveApiKeyBtn:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.03);
            box-shadow: 0 7px 20px rgba(var(--teal-mid-rgb), 0.25), 0 0 0 3px rgba(var(--teal-mid-rgb), 0.15);
        }
        #generate-btn:active:not(:disabled), #saveApiKeyBtn:active:not(:disabled) {
            transform: translateY(0px) scale(0.97);
            box-shadow: 0 3px 10px rgba(var(--teal-mid-rgb), 0.2);
        }
        #generate-btn:disabled, #saveApiKeyBtn:disabled { /* Assuming save button can also be disabled */
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--card-border-color);
            box-shadow: none;
        }
        .btn-icon, .loading-btn-icon {
             stroke: var(--bg-color);
        }
        .loading-btn-icon { animation: spin 0.8s linear infinite; }


        .results-area {
            min-height: 100px;
            width: 100%; 
            max-width: 850px; 
            margin-left: auto;
            margin-right: auto; 
        }

        .results-area h2 {
            color: var(--accent-color);
            margin-bottom: 20px;
            font-weight: 600;
            font-size: 1.3rem;
            text-align: center; 
        }

        #synonym-list {
            list-style: none;
            padding: 0;
        }

        .synonym-item {
            display: block;
            width: 100%; 
            max-width: 650px; 
            background-color: rgba(255, 255, 255, 0.025);
            padding: 16px 22px;
            margin: 0 auto 12px auto; 
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 400;
            color: var(--text-color);
            opacity: 0;
            transform: translateY(15px) scale(0.98);
            animation: fadeInListItem 0.5s var(--easing-decelerate) forwards;
            cursor: pointer;
            transition: background-color 0.2s var(--easing-standard),
                        color 0.2s var(--easing-standard),
                        transform 0.2s var(--easing-standard),
                        border-color 0.2s var(--easing-standard),
                        box-shadow 0.2s var(--easing-standard);
            border: 1px solid transparent;
            position: relative;
            overflow: hidden;
            text-align: center; 
        }

        .synonym-item:hover {
            background-color: rgba(var(--teal-mid-rgb), 0.15);
            color: var(--teal-light);
            border-color: rgba(var(--teal-mid-rgb), 0.4);
            transform: translateY(-2px) translateX(3px); 
            box-shadow: 0 4px 15px rgba(var(--teal-mid-rgb), 0.1);
        }
        .synonym-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.07), transparent);
            transition: left 0.5s var(--easing-standard);
            transform: skewX(-25deg);
        }
        .synonym-item:hover::before {
            left: 120%;
        }


        @keyframes fadeInListItem {
            from { opacity: 0; transform: translateY(15px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
         #synonym-list .synonym-item:nth-child(1) { animation-delay: 0.1s; }
         #synonym-list .synonym-item:nth-child(2) { animation-delay: 0.15s; }
         #synonym-list .synonym-item:nth-child(3) { animation-delay: 0.2s; }
         #synonym-list .synonym-item:nth-child(4) { animation-delay: 0.25s; }
         #synonym-list .synonym-item:nth-child(5) { animation-delay: 0.3s; }
         #synonym-list .synonym-item:nth-child(6) { animation-delay: 0.35s; }
         #synonym-list .synonym-item:nth-child(7) { animation-delay: 0.4s; }
         #synonym-list .synonym-item:nth-child(8) { animation-delay: 0.45s; }
         #synonym-list .synonym-item:nth-child(9) { animation-delay: 0.5s; }
         #synonym-list .synonym-item:nth-child(10) { animation-delay: 0.55s; }


        .loading-spinner {
            display: none;
            margin: 30px auto;
            width: 40px;
            height: 40px;
            border: 3px solid rgba(var(--teal-mid-rgb), 0.2);
            border-top: 3px solid var(--teal-mid);
            border-radius: 50%;
            animation: spin 0.7s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.05); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .message-box {
            padding: 14px 18px;
            border-radius: var(--border-radius);
            margin-top: 20px;
            font-size: 0.95rem;
            text-align: left; 
            border: 1px solid transparent;
            max-width: 650px; 
            margin-left: auto;
            margin-right: auto;
        }
        .error-message {
            color: var(--error-color);
            background-color: rgba(248, 81, 73, 0.1);
            border-color: rgba(248, 81, 73, 0.3);
        }
        .info-message-box {
             color: var(--text-color);
             background-color: rgba(var(--teal-mid-rgb), 0.05);
             border-color: rgba(var(--teal-mid-rgb), 0.2);
        }
        a {
            color: var(--accent-color);
            text-decoration: none;
            font-weight: 500;
        }
        a:hover {
            text-decoration: underline;
            color: var(--teal-light);
        }

        /* --- Modals (Centered, e.g., About Modal) --- */
        .modal-overlay {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%;
            background-color: var(--modal-backdrop-color);
            align-items: center; justify-content: center; padding: 20px;
            animation: fadeInModalBg 0.3s var(--easing-decelerate) forwards;
            overflow-y: auto; 
        }
        @keyframes fadeInModalBg { from { background-color: rgba(0,0,0,0); opacity: 0; } to { background-color: var(--modal-backdrop-color); opacity: 1; } }
        @keyframes fadeOutModalBg { from { background-color: var(--modal-backdrop-color); opacity: 1; } to { background-color: rgba(0,0,0,0); opacity: 0; } }

        .modal-content {
            background: var(--popover-bg);
            padding: 30px 35px;
            border: 1px solid var(--card-border-color);
            border-radius: var(--border-radius-large);
            width: 90%; max-width: 550px;
            box-shadow: 0 20px 70px rgba(0, 0, 0, 0.5);
            position: relative; opacity: 0;
            animation: slideInModalContent 0.4s var(--easing-decelerate) 0.05s forwards;
            text-align: left;
            margin: auto; 
        }
        @keyframes slideInModalContent { from { opacity: 0; transform: translateY(20px) scale(0.98); } to { opacity: 1; transform: translateY(0) scale(1); } }
        @keyframes slideOutModalContent { from { opacity: 1; transform: translateY(0) scale(1); } to { opacity: 0; transform: translateY(20px) scale(0.98); } }
        
        .modal-content h3 { color: var(--teal-light); margin-bottom: 15px; font-size: 1.5rem;}
        .modal-content p { margin-bottom: 15px; line-height: 1.6; color: rgba(240,240,240,0.85); }
        .modal-content p:last-child { margin-bottom: 0; }

        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 2rem;
            color: rgba(240, 240, 240, 0.5);
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            transition: color 0.2s var(--easing-standard), transform 0.2s var(--easing-standard);
            z-index: 10;
        }
        .modal-close-btn:hover {
            color: var(--text-color);
            transform: scale(1.1);
        }
        .api-key-modal-input-container { /* Container for API key input and label */
            margin-bottom: 10px; /* Spacing before save button */
        }
        .api-key-modal-input-container #apiKeyInput {
            width: 100%;
            margin-bottom: 8px; /* Space between input and label */
        }
        .api-key-modal-input-container label {
            font-size: 0.85rem;
            color: rgba(240,240,240,0.7);
            display: block;
            text-align: center;
            margin-bottom: 15px;
        }
        .modal-content .message-box { /* Ensure message box in modal is also centered if text-align:left is default */
            text-align: center;
        }


        /* --- Definition Popover (Next to word) --- */
        .definition-popover {
            display: none; position: absolute; z-index: 1010;
            background-color: var(--popover-bg);
            border: 1px solid var(--card-border-color);
            border-radius: var(--border-radius);
            padding: 18px 22px;
            min-width: 280px; max-width: 350px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            opacity: 0;
            transform: translateX(15px) scale(0.97);
            transition: opacity 0.25s var(--easing-decelerate), transform 0.25s var(--easing-decelerate);
            text-align: left;
        }
        .definition-popover.visible {
            display: block; opacity: 1; transform: translateX(0) scale(1);
            animation: popoverSlideInRight 0.25s var(--easing-decelerate);
        }
        @keyframes popoverSlideInRight {
            from { opacity: 0; transform: translateX(15px) scale(0.97); }
            to { opacity: 1; transform: translateX(0) scale(1); }
        }
        .definition-popover.popover-left {
            transform: translateX(-15px) scale(0.97);
        }
        .definition-popover.visible.popover-left {
            animation: popoverSlideInLeft 0.25s var(--easing-decelerate);
            transform: translateX(0) scale(1);
        }
        @keyframes popoverSlideInLeft {
            from { opacity: 0; transform: translateX(-15px) scale(0.97); }
            to { opacity: 1; transform: translateX(0) scale(1); }
        }
        .definition-popover::after {
            content: ""; position: absolute; top: 50%; left: -9px;
            transform: translateY(-50%); border-width: 9px; border-style: solid;
            border-color: transparent var(--popover-bg) transparent transparent;
        }
        .definition-popover.popover-left::after {
            left: auto; right: -9px;
            border-color: transparent transparent transparent var(--popover-bg);
        }

        #popover-word {
            color: var(--teal-light);
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(var(--teal-mid-rgb),0.2);
        }
        #popover-definition {
            font-size: 0.95rem;
            line-height: 1.65;
            color: rgba(240, 240, 240, 0.85);
            min-height: 30px;
        }
        #popover-definition-loader { margin: 10px auto; width: 24px; height: 24px; border-width: 3px; }
        #popover-error { margin-top: 10px; font-size: 0.85rem; }

        /* --- Copy Notification --- */
        .copy-notification {
            display: none; 
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%); 
            background-color: var(--teal-mid);
            color: var(--bg-color);
            padding: 10px 20px;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(var(--teal-mid-rgb), 0.2);
            z-index: 2000; 
            opacity: 0; 
            transition: opacity 0.3s var(--easing-standard); 
        }

        .copy-notification.show {
            display: block;
            opacity: 1;
            animation: slideUpNotification 0.3s var(--easing-decelerate) forwards;
        }

        @keyframes slideUpNotification { 
            from {
                transform: translateX(-50%) translateY(20px); 
            }
            to {
                transform: translateX(-50%) translateY(0); 
            }
        }


        /* --- Mobile Support --- */
        @media (max-width: 640px) {
            main {
                padding: 15px;
            }

            h1 {
                font-size: 2.2rem;
            }

            .header-title {
                gap: 8px;
                margin-bottom: 12px;
            }
            .header-title .info-icon { 
                width: 20px;
                height: 20px;
            }

            .tagline {
                font-size: 0.9rem;
                margin-bottom: 25px;
                max-width: 100%; 
            }

            .input-area {
                flex-direction: column;
                gap: 12px;
                margin-bottom: 25px;
                max-width: 100%; 
            }

            #word-input, #apiKeyInput {
                width: 100%;
                padding: 14px 18px;
                height: 50px;
                font-size: 1rem;
            }

            #generate-btn {
                width: 100%;
                height: 50px;
                border-radius: var(--border-radius); 
            }
            #generate-btn .btn-icon,
            #generate-btn .loading-btn-icon { 
                width: 20px;
                height: 20px;
            }
            #saveApiKeyBtn { /* Mobile adjustments for save button */
                width: 100%; 
                height: 50px;
            }


            .results-area {
                margin-top: 25px;
                min-height: 60px;
                max-width: 100%; 
            }
            .results-area h2 {
                font-size: 1.15rem;
                margin-bottom: 12px;
            }

            #synonym-list {
                padding-left: 0;
            }
            .synonym-item {
                width: 100%; 
                max-width: 100%; 
                padding: 12px 15px;
                font-size: 0.9rem;
            }
            .synonym-item:hover {
                transform: translateY(-2px); 
            }

            .loading-spinner { 
                width: 36px;
                height: 36px;
                margin: 25px auto;
            }
            .message-box {
                padding: 12px 15px;
                font-size: 0.9rem;
                max-width: 100%; 
            }

            .modal-overlay {
                padding: 10px; 
            }
            .modal-content {
                padding: 25px 20px;
                width: 100%; 
                max-width: 100%;
                margin: auto 0; 
            }
            .modal-content h3 {
                font-size: 1.3rem;
            }
            .modal-content p {
                font-size: 0.9rem;
                line-height: 1.55;
            }
            .modal-close-btn {
                top: 10px;
                right: 10px;
                font-size: 1.8rem;
            }

            .definition-popover {
                padding: 14px 18px;
                min-width: 0;
                width: calc(100vw - 20px); 
                max-width: calc(100vw - 20px); 
                box-sizing: border-box;
            }
            #popover-word {
                font-size: 1.05rem;
            }
            #popover-definition {
                font-size: 0.85rem;
                line-height: 1.6;
            }
            #popover-definition-loader { 
                width: 20px;
                height: 20px;
                border-width: 2px; 
            }

            .copy-notification {
                bottom: 20px;
                padding: 8px 15px;
                font-size: 0.85rem;
                width: calc(100% - 30px); 
                max-width: 300px; 
                box-sizing: border-box;
            }
        }
    </style>
</head>
<body>
<ethan-header></ethan-header>
<main>
    <div class="header-title">
        <h1>Thessa</h1>
        <svg id="thessa-info-btn" class="info-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="About Thessa">
            <circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>
        </svg>
        <svg id="settings-btn" class="info-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" title="Settings (API Key)">
            <circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </div>
    <p class="tagline">AI Thesaurus</p>
    
    <div class="input-area">
        <input type="text" id="word-input" placeholder="Enter a word or phrase (e.g., 'brilliant')">
        <button id="generate-btn" title="Generate Synonyms">
            <svg class="btn-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </button>
    </div>

    <div class="results-area">
        <div id="loading-spinner" class="loading-spinner"></div>
        <h2 id="results-title" style="display: none;">Synonyms:</h2>
        <ul id="synonym-list"></ul>
        <p id="message-box" class="message-box" style="display:none;"></p>
    </div>

<!-- About Thessa Modal -->
<div id="about-thessa-modal" class="modal-overlay">
    <div class="modal-content">
        <button class="modal-close-btn" id="about-modal-close-btn" aria-label="Close modal">×</button>
        <h3>About Thessa</h3>
        <p>Thessa is your AI-powered thesaurus.</p>
        <p>Simply enter a word, and Thessa will provide a curated list of synonyms, some common substitutes and some rare archaisms. The last synonym will be a Bulgarian cognate.</p>
        <p>Click on any synonym to get a concise definition generated by AI. Click the synonym again while the definition is open to copy it to your clipboard.</p>
        <p>To use Thessa, you'll need to provide your own <a href="https://aistudio.google.com/app/apikey">Google Gemini API key</a>. This key is stored securely in your browser's local storage. You can manage your API key via the settings icon (⚙️).</p>
        <p>Expand your vocabulary and refine your expression with Thessa!</p>
        <p style="font-size: 0.85em; opacity: 0.7;"><em>Powered by <a href="https://ai.google.dev/gemini-api" target="_blank" rel="noopener noreferrer">Google Gemini API</em></a></p>
    </div>
</div>

<!-- API Key Modal -->
<div id="apiKeyModal" class="modal-overlay">
    <div class="modal-content">
        <button class="modal-close-btn" id="apiKeyModalCloseBtn" aria-label="Close API Key modal">×</button>
        <h3>Enter Your API Key</h3>
        <p>Thessa requires a Gemini API key to function.</p>
        <p>If you don't already have one, you can create an API key via <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>.</p>
        <div class="api-key-modal-input-container">
             <input type="password" id="apiKeyInput" placeholder="Your Gemini API Key">
             <label for="apiKeyInput">Your key is stored locally in your browser and never sent anywhere except to Google's API.</label>
        </div>
        <button id="saveApiKeyBtn">Save</button>
        <p id="apiKeyError" class="message-box error-message" style="display:none; margin-top: 15px;"></p>
    </div>
</div>


<!-- Definition Popover -->
<div id="definition-popover" class="definition-popover">
    <h4 id="popover-word">Word</h4>
    <div id="popover-definition-loader" class="loading-spinner" style="display:none;"></div>
    <p id="popover-definition"></p>
    <p id="popover-error" class="message-box error-message" style="display:none;"></p>
</div>

<!-- Copy Notification -->
<div id="copy-notification" class="copy-notification">Copied to clipboard!</div>
</main>

<ethan-footer></ethan-footer>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('word-input').value = '';
        // Don't focus wordInput immediately if API key modal might show
        document.body.classList.remove('has-results'); // Ensure clean state on load

        // API Key Modal Setup
        if (!loadApiKey()) {
            showModal(apiKeyModal);
            apiKeyInput.focus(); // Focus API key input if modal is shown
        } else {
            wordInput.focus(); // Focus main input if key exists
        }

        saveApiKeyBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (saveApiKey(key)) {
                // Optional: re-focus main input after successful save
                // wordInput.focus(); 
            }
        });

        apiKeyModalCloseBtn.addEventListener('click', () => {
            hideModal(apiKeyModal);
        });
        apiKeyModal.addEventListener('click', (event) => {
            if (event.target === apiKeyModal) {
                 if (!userApiKey) {
                    apiKeyErrorEl.textContent = "An API Key is required. Click the 'x' or enter a key.";
                    apiKeyErrorEl.style.display = 'block';
                 } else {
                    hideModal(apiKeyModal);
                 }
            }
        });
        
        settingsBtn.addEventListener('click', () => {
            apiKeyInput.value = userApiKey || ''; 
            apiKeyErrorEl.style.display = 'none';
            showModal(apiKeyModal);
            apiKeyInput.focus();
        });

        document.getElementById('word-input').focus();
        document.body.classList.remove('has-results'); // Ensure clean state on load
    });

    const wordInput = document.getElementById('word-input');
    const generateBtn = document.getElementById('generate-btn');
    const synonymList = document.getElementById('synonym-list');
    const loadingSpinner = document.getElementById('loading-spinner');
    const resultsTitle = document.getElementById('results-title');
    const messageBoxEl = document.getElementById('message-box');

    const aboutThessaModal = document.getElementById('about-thessa-modal');
    const thessaInfoBtn = document.getElementById('thessa-info-btn');
    const aboutModalCloseBtn = document.getElementById('about-modal-close-btn');
    const settingsBtn = document.getElementById('settings-btn');

    const definitionPopover = document.getElementById('definition-popover');
    const popoverWordTitle = document.getElementById('popover-word');
    const popoverDefinitionLoader = document.getElementById('popover-definition-loader');
    const popoverDefinitionText = document.getElementById('popover-definition');
    const popoverErrorText = document.getElementById('popover-error');

    const copyNotificationEl = document.getElementById('copy-notification');
    let copyNotificationTimeout;

    const NUM_OF_SYNONYMS = 8;
    let currentOpenPopoverTarget = null;
    let currentSynonymIsBulgarian = false;

    // API Key related variables and constants
    let userApiKey = '';
    const API_KEY_STORAGE_KEY = 'thessaUserApiKey';
    const apiKeyModal = document.getElementById('apiKeyModal');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
    const apiKeyModalCloseBtn = document.getElementById('apiKeyModalCloseBtn');
    const apiKeyErrorEl = document.getElementById('apiKeyError');


    function loadApiKey() {
        const storedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
        if (storedKey) {
            userApiKey = storedKey;
            apiKeyErrorEl.style.display = 'none';
            return true;
        }
        return false;
    }

    function saveApiKey(key) {
        if (!key || key.trim() === '') {
            apiKeyErrorEl.textContent = "API Key cannot be empty.";
            apiKeyErrorEl.style.display = 'block';
            return false;
        }
        localStorage.setItem(API_KEY_STORAGE_KEY, key);
        userApiKey = key;
        apiKeyErrorEl.style.display = 'none';
        hideModal(apiKeyModal);
        displayMessage("API Key saved successfully. You can now use Thessa.", "info");
        // Clear previous search results or errors from main view if any
        clearResultsAndMessages(); 
        wordInput.focus();
        return true;
    }
    
    function getApiUrl() {
        if (!userApiKey) {
            return null;
        }
        return `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${userApiKey}`;
    }


    generateBtn.addEventListener('click', fetchSynonyms);
    wordInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') fetchSynonyms();
    });

    thessaInfoBtn.addEventListener('click', () => showModal(aboutThessaModal));
    aboutModalCloseBtn.addEventListener('click', () => hideModal(aboutThessaModal));
    aboutThessaModal.addEventListener('click', (event) => {
        if (event.target === aboutThessaModal) hideModal(aboutThessaModal);
    });
    
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
            if (aboutThessaModal.style.display === 'flex') {
                hideModal(aboutThessaModal);
            } else if (apiKeyModal.style.display === 'flex') {
                if (userApiKey) { 
                    hideModal(apiKeyModal);
                } else {
                    apiKeyErrorEl.textContent = "An API Key is required. Please enter one or click 'x' if you wish to close this and add it later via settings.";
                    apiKeyErrorEl.style.display = 'block';
                }
            } else if (definitionPopover.classList.contains('visible')) {
                hideDefinitionPopover();
            }
        }
    });


    document.addEventListener('click', function(event) {
        if (definitionPopover.classList.contains('visible')) {
            const isClickInsidePopover = definitionPopover.contains(event.target);
            const isClickOnPopoverTarget = currentOpenPopoverTarget && currentOpenPopoverTarget.contains(event.target);
            if (!isClickInsidePopover && !isClickOnPopoverTarget) {
                hideDefinitionPopover();
            }
        }
    });


    async function fetchSynonyms() {
        const word = wordInput.value.trim();
        
        document.body.classList.remove('has-results'); 

        if (!userApiKey) {
            displayMessage("API Key is not set. Please provide your API key via the settings (⚙️ icon) or the prompt.", "error");
            showModal(apiKeyModal);
            apiKeyInput.focus();
            return;
        }

        if (!word) {
            displayMessage("Please enter a word.", "error"); 
            return;
        }
        
        clearResultsAndMessages(); 
        hideDefinitionPopover();
        loadingSpinner.style.display = 'block';
        generateBtn.disabled = true;
        generateBtn.innerHTML = `
            <svg class="btn-icon loading-btn-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>`;

        const prompt = `Provide a list of diverse English synonyms for "${word}", limited to a maximum of ${NUM_OF_SYNONYMS}. Include some common synonyms as well as rare, esoteric ones. The ${NUM_OF_SYNONYMS}th and final synonym should be in Bulgarian. "${word}" cannot be in your list of synonyms. No repeats. Capitalize the first letter of each synonym. Newline separated. Each line should ONLY include the synonym. NEVER anything other than the synonym on the line. NEVER include parenthesis. Your response should only include the list without any introductory or concluding text. If none, say "No synonyms found for ${word}."`;
        
        const currentApiUrl = getApiUrl();
        if (!currentApiUrl) { // Should be caught by the earlier check, but good safety
            displayMessage("API Key is missing. Cannot fetch synonyms.", "error");
            showModal(apiKeyModal);
            loadingSpinner.style.display = 'none';
            generateBtn.disabled = false;
            generateBtn.innerHTML = `...`; // Reset button icon
            return;
        }

        try {
            const response = await fetch(currentApiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.65, maxOutputTokens: 300 }
                }),
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
                const err = new Error(errorData.error?.message || `HTTP error ${response.status}`);
                err.httpStatus = response.status; 
                throw err;
            }

            const data = await response.json();
            const textResponse = data.candidates?.[0]?.content?.parts?.[0]?.text;

            if (textResponse) {
                displaySynonyms(textResponse, word);
            } else if (data.promptFeedback?.blockReason) {
                displayMessage(`Content blocked: ${data.promptFeedback.blockReason}`, "error");
            } else {
                displayMessage("Could not parse synonyms from API response.", "error");
            }
        } catch (error) {
            console.error('Error fetching synonyms:', error);
            let errorMessage = `Error: ${error.message || "Unknown API error."}`;
            if (error.name === 'TypeError' && error.message.toLowerCase().includes('failed to fetch')) {
                errorMessage = "Network error. Please check your internet connection.";
            } else if (error.httpStatus) {
                if ([400, 401, 403].includes(error.httpStatus)) {
                    errorMessage = `API Error (${error.httpStatus}): ${error.message} This might be due to an invalid or incorrectly configured API Key. Please check and update your key via settings (⚙️).`;
                    localStorage.removeItem(API_KEY_STORAGE_KEY); // Clear potentially bad key
                    userApiKey = '';
                    setTimeout(() => {
                        showModal(apiKeyModal);
                        apiKeyInput.focus();
                    }, 500);
                } else {
                    errorMessage = `API Error (${error.httpStatus}): ${error.message}`;
                }
            }
            displayMessage(errorMessage, "error");
        } finally {
            loadingSpinner.style.display = 'none';
            generateBtn.disabled = false;
            generateBtn.innerHTML = `
                <svg class="btn-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
        }
    }

    function displaySynonyms(responseText, originalWord) {
        resultsTitle.style.display = 'block';
        resultsTitle.textContent = `Synonyms for "${originalWord}"`;

        const lines = responseText.split('\n')
            .map(line => line.trim())
            .filter(line => line && !/^(here is|sure,)/i.test(line.toLowerCase()));
        
        if (lines.length === 0 || /no synonyms found/i.test(responseText.toLowerCase())) {
            displayMessage(`No synonyms found for "${originalWord}".`, "info"); 
            resultsTitle.style.display = 'none';
            document.body.classList.remove('has-results'); 
        } else {
            const limitedLines = lines.slice(0, NUM_OF_SYNONYMS); 
            limitedLines.forEach((item, index) => {
                const li = document.createElement('li');
                const cleanSynonym = item.replace(/^[\*\-]\s*|\s*\(.*\)\s*$/, '');
                li.textContent = cleanSynonym;
                li.classList.add('synonym-item');
                
                const isBulgarianSynonym = /[а-яА-Я]+/g.test(cleanSynonym);
                
                li.addEventListener('click', (e) => handleSynonymClick(cleanSynonym, e.currentTarget, isBulgarianSynonym)); 
                synonymList.appendChild(li);
            });
            document.body.classList.add('has-results'); 
        }
    }
    
    function displayMessage(message, type = "error") {
        messageBoxEl.textContent = message;
        messageBoxEl.className = `message-box ${type === 'error' ? 'error-message' : 'info-message-box'}`;
        messageBoxEl.style.display = 'block';
        if (type === 'error') {
            resultsTitle.style.display = 'none';
            document.body.classList.remove('has-results'); 
        }
    }
    
    function clearResultsAndMessages() {
        synonymList.innerHTML = '';
        resultsTitle.style.display = 'none';
        messageBoxEl.style.display = 'none';
        document.body.classList.remove('has-results'); 
    }

    function handleSynonymClick(synonym, targetElement, isBulgarian = false) { 
        if (targetElement === currentOpenPopoverTarget && definitionPopover.classList.contains('visible')) {
            const textToCopy = synonym.toLowerCase();
            navigator.clipboard.writeText(textToCopy)
                .then(() => {
                    showCopyNotification(`Copied "${textToCopy}"!`);
                })
                .catch(err => {
                    console.error('Failed to copy text: ', err);
                    showCopyNotification("Failed to copy!", true); 
                });
            return; 
        }

        currentOpenPopoverTarget = targetElement;
        currentSynonymIsBulgarian = isBulgarian;
        positionAndShowDefinitionPopover(synonym, targetElement); 
        fetchDefinitionForPopover(synonym); 
    }

    async function fetchDefinitionForPopover(word) {
        popoverDefinitionText.textContent = '';
        popoverErrorText.style.display = 'none';
        popoverDefinitionLoader.style.display = 'block';

        if (!userApiKey) { // Check API key before fetching definition
            updatePopoverWithError("API Key not set. Please configure it in settings (⚙️).");
            showModal(apiKeyModal); // Prompt for key
            return;
        }

        const prompt = `Provide a CONCISE English definition for the word "${word}". Respond with only the definition text, without any introductory phrases or formatting. If the word could have multiple meanings, list them each in a seperate sentence.`;
        const currentApiUrl = getApiUrl();

        try {
            const response = await fetch(currentApiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.3, maxOutputTokens: 200 }
                }),
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
                const err = new Error(errorData.error?.message || `HTTP error ${response.status}`);
                err.httpStatus = response.status;
                throw err;
            }
            const data = await response.json();
            const definition = data.candidates?.[0]?.content?.parts?.[0]?.text;

            if (definition) {
                updatePopoverWithDefinition(definition.trim());
            } else if (data.promptFeedback?.blockReason) {
                updatePopoverWithError(`Definition blocked: ${data.promptFeedback.blockReason}`);
            } else {
                updatePopoverWithError("Could not parse definition.");
            }
        } catch (error) {
            console.error('Error fetching definition:', error);
            let errorMessage = `API Error: ${error.message || "Unknown."}`;
             if (error.httpStatus && [400, 401, 403].includes(error.httpStatus)) {
                errorMessage = `API Error (${error.httpStatus}): Invalid Key or Request. Check settings (⚙️).`;
                localStorage.removeItem(API_KEY_STORAGE_KEY);
                userApiKey = '';
                setTimeout(() => {
                    showModal(apiKeyModal);
                    apiKeyInput.focus();
                }, 200); // Shorter delay for popover
            }
            updatePopoverWithError(errorMessage);
        }
    }

    function positionAndShowDefinitionPopover(word, targetElement) {
        definitionPopover.classList.remove('visible', 'popover-left');
        
        let popoverWordContent = word;
        if (currentSynonymIsBulgarian) { 
            popoverWordContent += ' 🇧🇬';
        }
        popoverWordTitle.textContent = popoverWordContent;
        
        popoverDefinitionText.textContent = '';
        popoverErrorText.style.display = 'none';
        popoverDefinitionLoader.style.display = 'block'; // Show loader initially

        definitionPopover.style.display = 'block'; 

        const rect = targetElement.getBoundingClientRect();
        const popoverHeight = definitionPopover.offsetHeight;
        let popoverWidth = definitionPopover.offsetWidth; 
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const scrollY = window.scrollY;
        const scrollX = window.scrollX;

        let top = rect.top + scrollY + (rect.height / 2) - (popoverHeight);
        let left = rect.right + scrollX + 14; 
        let useLeft = false;

        if (left + popoverWidth > viewportWidth - 10) { 
            left = rect.left + scrollX - popoverWidth - 14; 
            useLeft = true;
        }
        if (left < 10) { 
             left = 10;
             if (useLeft && (rect.left + scrollX - popoverWidth - 14 < 10)) { 
                if (rect.right + scrollX + 14 + popoverWidth < viewportWidth -10) {
                    left = rect.right + scrollX + 14;
                    useLeft = false;
                }
             }
        }
        if (!useLeft && (left + popoverWidth > viewportWidth - 10)) {
            left = viewportWidth - popoverWidth - 10;
            if (left < 10) left = 10; 
        }
        
        if (top < scrollY + 10) { 
            top = scrollY + 10;
        } else if (top + popoverHeight > scrollY + viewportHeight - 10) { 
            top = scrollY + viewportHeight - popoverHeight - 10;
        }
        if (top < scrollY + 10) top = scrollY + 10; 


        definitionPopover.style.top = `${top}px`;
        definitionPopover.style.left = `${left}px`;

        definitionPopover.classList.remove('popover-left'); 
        if (useLeft) {
            definitionPopover.classList.add('popover-left');
        }
        definitionPopover.classList.add('visible');
    }

    function updatePopoverWithDefinition(definition) {
        popoverDefinitionLoader.style.display = 'none';
        popoverDefinitionText.textContent = definition;
    }

    function updatePopoverWithError(message) {
        popoverDefinitionLoader.style.display = 'none';
        popoverDefinitionText.textContent = '';
        popoverErrorText.textContent = message;
        popoverErrorText.style.display = 'block';
    }

    function hideDefinitionPopover() {
        definitionPopover.classList.remove('visible');
        currentOpenPopoverTarget = null;
        currentSynonymIsBulgarian = false;
        setTimeout(() => {
            if (!definitionPopover.classList.contains('visible')) {
                definitionPopover.style.display = 'none';
                popoverDefinitionLoader.style.display = 'none';
                popoverErrorText.style.display = 'none';
            }
        }, 250); 
    }

    function showModal(modalElement) {
        modalElement.style.display = 'flex';
        document.body.style.overflow = 'hidden'; // Prevent background scroll when modal is open
         // Ensure correct animations are set if they were cleared
        modalElement.style.animationName = 'fadeInModalBg';
        if (modalElement.querySelector('.modal-content')) {
            modalElement.querySelector('.modal-content').style.animationName = 'slideInModalContent';
        }
    }

    function hideModal(modalElement) {
        modalElement.style.animationName = 'fadeOutModalBg'; 
        if (modalElement.querySelector('.modal-content')) {
             modalElement.querySelector('.modal-content').style.animationName = 'slideOutModalContent';
        }

        setTimeout(() => {
            modalElement.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restore scroll
            // Reset animation names so they can play again next time
            modalElement.style.animationName = '';
            if (modalElement.querySelector('.modal-content')) {
                modalElement.querySelector('.modal-content').style.animationName = '';
            }
        }, 300); // Match animation duration
    }

    function showCopyNotification(message = "Copied to clipboard!", isError = false) {
        copyNotificationEl.textContent = message;
        copyNotificationEl.style.backgroundColor = isError ? 'var(--error-color)' : 'var(--teal-mid)';
        copyNotificationEl.style.color = isError ? 'var(--text-color)' : 'var(--bg-color)';
        
        copyNotificationEl.classList.add('show');

        clearTimeout(copyNotificationTimeout);
        copyNotificationTimeout = setTimeout(() => {
            copyNotificationEl.classList.remove('show'); 
            
            setTimeout(() => {
                if (!copyNotificationEl.classList.contains('show')) { 
                    copyNotificationEl.style.display = 'none';
                    copyNotificationEl.style.backgroundColor = ''; 
                    copyNotificationEl.style.color = '';
                }
            }, 300); 
        }, 2000); 
    }
</script>
</body>
</html>